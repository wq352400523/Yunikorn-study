// Code generated by protoc-gen-go. DO NOT EDIT.
// source: yunikorn-scheduler-interface/si.proto

package si

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	descriptor "github.com/golang/protobuf/protoc-gen-go/descriptor"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Scheduler can send action to RM.
type UpdateResponse_ActionFromScheduler int32

const (
	// Nothing needs to do
	UpdateResponse_NOACTION UpdateResponse_ActionFromScheduler = 0
	// Something is wrong, RM needs to stop the RM, and re-register with scheduler.
	UpdateResponse_RESYNC UpdateResponse_ActionFromScheduler = 1
)

var UpdateResponse_ActionFromScheduler_name = map[int32]string{
	0: "NOACTION",
	1: "RESYNC",
}

var UpdateResponse_ActionFromScheduler_value = map[string]int32{
	"NOACTION": 0,
	"RESYNC":   1,
}

func (x UpdateResponse_ActionFromScheduler) String() string {
	return proto.EnumName(UpdateResponse_ActionFromScheduler_name, int32(x))
}

func (UpdateResponse_ActionFromScheduler) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{3, 0}
}

// Following 4 operators can be specified, by default is "IN".
// When EXIST/NOT_EXISTS specified, scheduler only check if given targetKey
// appears on node attribute or allocation tag.
type AffinityTargetExpression_AffinityTargetOperator int32

const (
	AffinityTargetExpression_IN        AffinityTargetExpression_AffinityTargetOperator = 0
	AffinityTargetExpression_NOT_IN    AffinityTargetExpression_AffinityTargetOperator = 1
	AffinityTargetExpression_EXIST     AffinityTargetExpression_AffinityTargetOperator = 2
	AffinityTargetExpression_NOT_EXIST AffinityTargetExpression_AffinityTargetOperator = 3
)

var AffinityTargetExpression_AffinityTargetOperator_name = map[int32]string{
	0: "IN",
	1: "NOT_IN",
	2: "EXIST",
	3: "NOT_EXIST",
}

var AffinityTargetExpression_AffinityTargetOperator_value = map[string]int32{
	"IN":        0,
	"NOT_IN":    1,
	"EXIST":     2,
	"NOT_EXIST": 3,
}

func (x AffinityTargetExpression_AffinityTargetOperator) String() string {
	return proto.EnumName(AffinityTargetExpression_AffinityTargetOperator_name, int32(x))
}

func (AffinityTargetExpression_AffinityTargetOperator) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{19, 0}
}

// Action from RM
type UpdateNodeInfo_ActionFromRM int32

const (
	// Do not allocate new allocations on the node.
	UpdateNodeInfo_DRAIN_NODE UpdateNodeInfo_ActionFromRM = 0
	// Decomission node, it will immediately stop allocations on the node and
	// remove the node from schedulable lists.
	UpdateNodeInfo_DECOMISSION UpdateNodeInfo_ActionFromRM = 1
	// From Draining state to SCHEDULABLE state.
	// If node is not in draining state, error will be thrown
	UpdateNodeInfo_DRAIN_TO_SCHEDULABLE UpdateNodeInfo_ActionFromRM = 2
)

var UpdateNodeInfo_ActionFromRM_name = map[int32]string{
	0: "DRAIN_NODE",
	1: "DECOMISSION",
	2: "DRAIN_TO_SCHEDULABLE",
}

var UpdateNodeInfo_ActionFromRM_value = map[string]int32{
	"DRAIN_NODE":           0,
	"DECOMISSION":          1,
	"DRAIN_TO_SCHEDULABLE": 2,
}

func (x UpdateNodeInfo_ActionFromRM) String() string {
	return proto.EnumName(UpdateNodeInfo_ActionFromRM_name, int32(x))
}

func (UpdateNodeInfo_ActionFromRM) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{24, 0}
}

type AllocationReleaseResponse_TerminationType int32

const (
	// STOPPED by ResourceManager.
	AllocationReleaseResponse_STOPPED_BY_RM AllocationReleaseResponse_TerminationType = 0
	// TIMEOUT based on the executionTimeoutMilliSeconds
	AllocationReleaseResponse_TIMEOUT AllocationReleaseResponse_TerminationType = 1
	// PREEMPTED by scheduler
	AllocationReleaseResponse_PREEMPTED_BY_SCHEDULER AllocationReleaseResponse_TerminationType = 2
)

var AllocationReleaseResponse_TerminationType_name = map[int32]string{
	0: "STOPPED_BY_RM",
	1: "TIMEOUT",
	2: "PREEMPTED_BY_SCHEDULER",
}

var AllocationReleaseResponse_TerminationType_value = map[string]int32{
	"STOPPED_BY_RM":          0,
	"TIMEOUT":                1,
	"PREEMPTED_BY_SCHEDULER": 2,
}

func (x AllocationReleaseResponse_TerminationType) String() string {
	return proto.EnumName(AllocationReleaseResponse_TerminationType_name, int32(x))
}

func (AllocationReleaseResponse_TerminationType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{29, 0}
}

//
//service MetricsService {
//}
type RegisterResourceManagerRequest struct {
	// An ID which can uniquely identify a RM **cluster**. (For example, if a RM cluster has multiple manager instances for HA purpose, they should use the same information when do registration).
	// If RM register with the same id, all previous scheduling state in memory will be cleaned up, and expect RM report full scheduling state after registration.
	RmId string `protobuf:"bytes,1,opt,name=rmId,proto3" json:"rmId,omitempty"`
	// Version of RM scheduler interface client.
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// Policy group name:
	// This defines which policy to use. Policy should be statically configured. (Think about network security group concept of ec2).
	// Different RMs can refer to the same policyGroup if their static configuration is identical.
	PolicyGroup          string   `protobuf:"bytes,3,opt,name=policyGroup,proto3" json:"policyGroup,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RegisterResourceManagerRequest) Reset()         { *m = RegisterResourceManagerRequest{} }
func (m *RegisterResourceManagerRequest) String() string { return proto.CompactTextString(m) }
func (*RegisterResourceManagerRequest) ProtoMessage()    {}
func (*RegisterResourceManagerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{0}
}

func (m *RegisterResourceManagerRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RegisterResourceManagerRequest.Unmarshal(m, b)
}
func (m *RegisterResourceManagerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RegisterResourceManagerRequest.Marshal(b, m, deterministic)
}
func (m *RegisterResourceManagerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterResourceManagerRequest.Merge(m, src)
}
func (m *RegisterResourceManagerRequest) XXX_Size() int {
	return xxx_messageInfo_RegisterResourceManagerRequest.Size(m)
}
func (m *RegisterResourceManagerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterResourceManagerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterResourceManagerRequest proto.InternalMessageInfo

func (m *RegisterResourceManagerRequest) GetRmId() string {
	if m != nil {
		return m.RmId
	}
	return ""
}

func (m *RegisterResourceManagerRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *RegisterResourceManagerRequest) GetPolicyGroup() string {
	if m != nil {
		return m.PolicyGroup
	}
	return ""
}

// Upon success, scheduler returns RegisterResourceManagerResponse to RM, otherwise RM receives exception.
type RegisterResourceManagerResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RegisterResourceManagerResponse) Reset()         { *m = RegisterResourceManagerResponse{} }
func (m *RegisterResourceManagerResponse) String() string { return proto.CompactTextString(m) }
func (*RegisterResourceManagerResponse) ProtoMessage()    {}
func (*RegisterResourceManagerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{1}
}

func (m *RegisterResourceManagerResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RegisterResourceManagerResponse.Unmarshal(m, b)
}
func (m *RegisterResourceManagerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RegisterResourceManagerResponse.Marshal(b, m, deterministic)
}
func (m *RegisterResourceManagerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterResourceManagerResponse.Merge(m, src)
}
func (m *RegisterResourceManagerResponse) XXX_Size() int {
	return xxx_messageInfo_RegisterResourceManagerResponse.Size(m)
}
func (m *RegisterResourceManagerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterResourceManagerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterResourceManagerResponse proto.InternalMessageInfo

type UpdateRequest struct {
	// New allocation requests or replace existing allocation request (if allocation-id is same)
	Asks []*AllocationAsk `protobuf:"bytes,1,rep,name=asks,proto3" json:"asks,omitempty"`
	// Allocations can be released.
	Releases *AllocationReleasesRequest `protobuf:"bytes,2,opt,name=releases,proto3" json:"releases,omitempty"`
	// New node can be scheduled. If a node is notified to be "unscheduable", it needs to be part of this field as well.
	NewSchedulableNodes []*NewNodeInfo `protobuf:"bytes,3,rep,name=newSchedulableNodes,proto3" json:"newSchedulableNodes,omitempty"`
	// Update nodes for existing schedulable nodes.
	// May include:
	// - Node resource changes. (Like grows/shrinks node resource)
	// - Node attribute changes. (Including node-partition concept like YARN, and concept like "local images".
	//
	// Should not include:
	// - Allocation-related changes with the node.
	// - Realtime Utilizations.
	UpdatedNodes []*UpdateNodeInfo `protobuf:"bytes,4,rep,name=updatedNodes,proto3" json:"updatedNodes,omitempty"`
	// UtilizationReports for allocation and nodes.
	UtilizationReports []*UtilizationReport `protobuf:"bytes,5,rep,name=utilizationReports,proto3" json:"utilizationReports,omitempty"`
	// Id of RM, this will be used to identify which RM of the request comes from.
	RmId string `protobuf:"bytes,6,opt,name=rmId,proto3" json:"rmId,omitempty"`
	// RM should explicitly add application when allocation request also explictly belongs to application.
	// This is optional if allocation request doesn't belong to a application. (Independent allocation)
	NewApplications []*AddApplicationRequest `protobuf:"bytes,8,rep,name=newApplications,proto3" json:"newApplications,omitempty"`
	// RM can also remove applications, all allocation/allocation requests associated with the application will be removed
	RemoveApplications   []*RemoveApplicationRequest `protobuf:"bytes,9,rep,name=removeApplications,proto3" json:"removeApplications,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *UpdateRequest) Reset()         { *m = UpdateRequest{} }
func (m *UpdateRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateRequest) ProtoMessage()    {}
func (*UpdateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{2}
}

func (m *UpdateRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UpdateRequest.Unmarshal(m, b)
}
func (m *UpdateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UpdateRequest.Marshal(b, m, deterministic)
}
func (m *UpdateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateRequest.Merge(m, src)
}
func (m *UpdateRequest) XXX_Size() int {
	return xxx_messageInfo_UpdateRequest.Size(m)
}
func (m *UpdateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateRequest proto.InternalMessageInfo

func (m *UpdateRequest) GetAsks() []*AllocationAsk {
	if m != nil {
		return m.Asks
	}
	return nil
}

func (m *UpdateRequest) GetReleases() *AllocationReleasesRequest {
	if m != nil {
		return m.Releases
	}
	return nil
}

func (m *UpdateRequest) GetNewSchedulableNodes() []*NewNodeInfo {
	if m != nil {
		return m.NewSchedulableNodes
	}
	return nil
}

func (m *UpdateRequest) GetUpdatedNodes() []*UpdateNodeInfo {
	if m != nil {
		return m.UpdatedNodes
	}
	return nil
}

func (m *UpdateRequest) GetUtilizationReports() []*UtilizationReport {
	if m != nil {
		return m.UtilizationReports
	}
	return nil
}

func (m *UpdateRequest) GetRmId() string {
	if m != nil {
		return m.RmId
	}
	return ""
}

func (m *UpdateRequest) GetNewApplications() []*AddApplicationRequest {
	if m != nil {
		return m.NewApplications
	}
	return nil
}

func (m *UpdateRequest) GetRemoveApplications() []*RemoveApplicationRequest {
	if m != nil {
		return m.RemoveApplications
	}
	return nil
}

type UpdateResponse struct {
	// What RM needs to do, scheduler can send control code to RM when something goes wrong.
	// Don't use/expand this field for other general purposed actions. (Like kill a remote container process).
	Action UpdateResponse_ActionFromScheduler `protobuf:"varint,1,opt,name=action,proto3,enum=si.v1.UpdateResponse_ActionFromScheduler" json:"action,omitempty"`
	// New allocations
	NewAllocations []*Allocation `protobuf:"bytes,2,rep,name=newAllocations,proto3" json:"newAllocations,omitempty"`
	// Released allocations, this could be either ack from scheduler when RM asks to terminate some allocations. Or
	// it could be decision made by scheduler (such as preemption).
	ReleasedAllocations []*AllocationReleaseResponse `protobuf:"bytes,3,rep,name=releasedAllocations,proto3" json:"releasedAllocations,omitempty"`
	// Rejected allocation requests
	RejectedAllocations []*RejectedAllocationAsk `protobuf:"bytes,4,rep,name=rejectedAllocations,proto3" json:"rejectedAllocations,omitempty"`
	// Suggested node update.
	// This could include:
	// 1) Schedulable resources on each node. This can be used when we want to run
	//    two resource management systems side-by-side. For example, YARN/K8s running side by side.
	//    and update YARN NodeManager / Kubelet resource dynamically.
	// 2) Other recommendations.
	NodeRecommendations []*NodeRecommendation `protobuf:"bytes,5,rep,name=nodeRecommendations,proto3" json:"nodeRecommendations,omitempty"`
	// Rejected Applications
	RejectedApplications []*RejectedApplication `protobuf:"bytes,6,rep,name=rejectedApplications,proto3" json:"rejectedApplications,omitempty"`
	// Accepted Applications
	AcceptedApplications []*AcceptedApplication `protobuf:"bytes,7,rep,name=acceptedApplications,proto3" json:"acceptedApplications,omitempty"`
	// Rejected Node Registrations
	RejectedNodes []*RejectedNode `protobuf:"bytes,8,rep,name=rejectedNodes,proto3" json:"rejectedNodes,omitempty"`
	// Accepted Node Registrations
	AcceptedNodes        []*AcceptedNode `protobuf:"bytes,9,rep,name=acceptedNodes,proto3" json:"acceptedNodes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *UpdateResponse) Reset()         { *m = UpdateResponse{} }
func (m *UpdateResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateResponse) ProtoMessage()    {}
func (*UpdateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{3}
}

func (m *UpdateResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UpdateResponse.Unmarshal(m, b)
}
func (m *UpdateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UpdateResponse.Marshal(b, m, deterministic)
}
func (m *UpdateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateResponse.Merge(m, src)
}
func (m *UpdateResponse) XXX_Size() int {
	return xxx_messageInfo_UpdateResponse.Size(m)
}
func (m *UpdateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateResponse proto.InternalMessageInfo

func (m *UpdateResponse) GetAction() UpdateResponse_ActionFromScheduler {
	if m != nil {
		return m.Action
	}
	return UpdateResponse_NOACTION
}

func (m *UpdateResponse) GetNewAllocations() []*Allocation {
	if m != nil {
		return m.NewAllocations
	}
	return nil
}

func (m *UpdateResponse) GetReleasedAllocations() []*AllocationReleaseResponse {
	if m != nil {
		return m.ReleasedAllocations
	}
	return nil
}

func (m *UpdateResponse) GetRejectedAllocations() []*RejectedAllocationAsk {
	if m != nil {
		return m.RejectedAllocations
	}
	return nil
}

func (m *UpdateResponse) GetNodeRecommendations() []*NodeRecommendation {
	if m != nil {
		return m.NodeRecommendations
	}
	return nil
}

func (m *UpdateResponse) GetRejectedApplications() []*RejectedApplication {
	if m != nil {
		return m.RejectedApplications
	}
	return nil
}

func (m *UpdateResponse) GetAcceptedApplications() []*AcceptedApplication {
	if m != nil {
		return m.AcceptedApplications
	}
	return nil
}

func (m *UpdateResponse) GetRejectedNodes() []*RejectedNode {
	if m != nil {
		return m.RejectedNodes
	}
	return nil
}

func (m *UpdateResponse) GetAcceptedNodes() []*AcceptedNode {
	if m != nil {
		return m.AcceptedNodes
	}
	return nil
}

type RejectedApplication struct {
	// The application ID that was rejected
	ApplicationId string `protobuf:"bytes,1,opt,name=applicationId,proto3" json:"applicationId,omitempty"`
	// A human-readable reason message
	Reason               string   `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RejectedApplication) Reset()         { *m = RejectedApplication{} }
func (m *RejectedApplication) String() string { return proto.CompactTextString(m) }
func (*RejectedApplication) ProtoMessage()    {}
func (*RejectedApplication) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{4}
}

func (m *RejectedApplication) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RejectedApplication.Unmarshal(m, b)
}
func (m *RejectedApplication) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RejectedApplication.Marshal(b, m, deterministic)
}
func (m *RejectedApplication) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RejectedApplication.Merge(m, src)
}
func (m *RejectedApplication) XXX_Size() int {
	return xxx_messageInfo_RejectedApplication.Size(m)
}
func (m *RejectedApplication) XXX_DiscardUnknown() {
	xxx_messageInfo_RejectedApplication.DiscardUnknown(m)
}

var xxx_messageInfo_RejectedApplication proto.InternalMessageInfo

func (m *RejectedApplication) GetApplicationId() string {
	if m != nil {
		return m.ApplicationId
	}
	return ""
}

func (m *RejectedApplication) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type AcceptedApplication struct {
	// The application ID that was accepted
	ApplicationId        string   `protobuf:"bytes,1,opt,name=applicationId,proto3" json:"applicationId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AcceptedApplication) Reset()         { *m = AcceptedApplication{} }
func (m *AcceptedApplication) String() string { return proto.CompactTextString(m) }
func (*AcceptedApplication) ProtoMessage()    {}
func (*AcceptedApplication) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{5}
}

func (m *AcceptedApplication) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AcceptedApplication.Unmarshal(m, b)
}
func (m *AcceptedApplication) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AcceptedApplication.Marshal(b, m, deterministic)
}
func (m *AcceptedApplication) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptedApplication.Merge(m, src)
}
func (m *AcceptedApplication) XXX_Size() int {
	return xxx_messageInfo_AcceptedApplication.Size(m)
}
func (m *AcceptedApplication) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptedApplication.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptedApplication proto.InternalMessageInfo

func (m *AcceptedApplication) GetApplicationId() string {
	if m != nil {
		return m.ApplicationId
	}
	return ""
}

type RejectedNode struct {
	// The node ID that was rejected
	NodeId string `protobuf:"bytes,1,opt,name=nodeId,proto3" json:"nodeId,omitempty"`
	// A human-readable reason message
	Reason               string   `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RejectedNode) Reset()         { *m = RejectedNode{} }
func (m *RejectedNode) String() string { return proto.CompactTextString(m) }
func (*RejectedNode) ProtoMessage()    {}
func (*RejectedNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{6}
}

func (m *RejectedNode) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RejectedNode.Unmarshal(m, b)
}
func (m *RejectedNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RejectedNode.Marshal(b, m, deterministic)
}
func (m *RejectedNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RejectedNode.Merge(m, src)
}
func (m *RejectedNode) XXX_Size() int {
	return xxx_messageInfo_RejectedNode.Size(m)
}
func (m *RejectedNode) XXX_DiscardUnknown() {
	xxx_messageInfo_RejectedNode.DiscardUnknown(m)
}

var xxx_messageInfo_RejectedNode proto.InternalMessageInfo

func (m *RejectedNode) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *RejectedNode) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type AcceptedNode struct {
	// The node ID that was accepted
	NodeId               string   `protobuf:"bytes,1,opt,name=nodeId,proto3" json:"nodeId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AcceptedNode) Reset()         { *m = AcceptedNode{} }
func (m *AcceptedNode) String() string { return proto.CompactTextString(m) }
func (*AcceptedNode) ProtoMessage()    {}
func (*AcceptedNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{7}
}

func (m *AcceptedNode) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AcceptedNode.Unmarshal(m, b)
}
func (m *AcceptedNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AcceptedNode.Marshal(b, m, deterministic)
}
func (m *AcceptedNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptedNode.Merge(m, src)
}
func (m *AcceptedNode) XXX_Size() int {
	return xxx_messageInfo_AcceptedNode.Size(m)
}
func (m *AcceptedNode) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptedNode.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptedNode proto.InternalMessageInfo

func (m *AcceptedNode) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

type Priority struct {
	// Types that are valid to be assigned to Priority:
	//	*Priority_PriorityValue
	//	*Priority_PriorityClassName
	Priority             isPriority_Priority `protobuf_oneof:"priority"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Priority) Reset()         { *m = Priority{} }
func (m *Priority) String() string { return proto.CompactTextString(m) }
func (*Priority) ProtoMessage()    {}
func (*Priority) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{8}
}

func (m *Priority) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Priority.Unmarshal(m, b)
}
func (m *Priority) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Priority.Marshal(b, m, deterministic)
}
func (m *Priority) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Priority.Merge(m, src)
}
func (m *Priority) XXX_Size() int {
	return xxx_messageInfo_Priority.Size(m)
}
func (m *Priority) XXX_DiscardUnknown() {
	xxx_messageInfo_Priority.DiscardUnknown(m)
}

var xxx_messageInfo_Priority proto.InternalMessageInfo

type isPriority_Priority interface {
	isPriority_Priority()
}

type Priority_PriorityValue struct {
	PriorityValue int32 `protobuf:"varint,1,opt,name=priorityValue,proto3,oneof"`
}

type Priority_PriorityClassName struct {
	PriorityClassName string `protobuf:"bytes,2,opt,name=priorityClassName,proto3,oneof"`
}

func (*Priority_PriorityValue) isPriority_Priority() {}

func (*Priority_PriorityClassName) isPriority_Priority() {}

func (m *Priority) GetPriority() isPriority_Priority {
	if m != nil {
		return m.Priority
	}
	return nil
}

func (m *Priority) GetPriorityValue() int32 {
	if x, ok := m.GetPriority().(*Priority_PriorityValue); ok {
		return x.PriorityValue
	}
	return 0
}

func (m *Priority) GetPriorityClassName() string {
	if x, ok := m.GetPriority().(*Priority_PriorityClassName); ok {
		return x.PriorityClassName
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Priority) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Priority_PriorityValue)(nil),
		(*Priority_PriorityClassName)(nil),
	}
}

// A sparse map of resource to Quantity.
type Resource struct {
	Resources            map[string]*Quantity `protobuf:"bytes,1,rep,name=resources,proto3" json:"resources,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Resource) Reset()         { *m = Resource{} }
func (m *Resource) String() string { return proto.CompactTextString(m) }
func (*Resource) ProtoMessage()    {}
func (*Resource) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{9}
}

func (m *Resource) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Resource.Unmarshal(m, b)
}
func (m *Resource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Resource.Marshal(b, m, deterministic)
}
func (m *Resource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Resource.Merge(m, src)
}
func (m *Resource) XXX_Size() int {
	return xxx_messageInfo_Resource.Size(m)
}
func (m *Resource) XXX_DiscardUnknown() {
	xxx_messageInfo_Resource.DiscardUnknown(m)
}

var xxx_messageInfo_Resource proto.InternalMessageInfo

func (m *Resource) GetResources() map[string]*Quantity {
	if m != nil {
		return m.Resources
	}
	return nil
}

// Quantity includes a single int64 value
type Quantity struct {
	Value                int64    `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Quantity) Reset()         { *m = Quantity{} }
func (m *Quantity) String() string { return proto.CompactTextString(m) }
func (*Quantity) ProtoMessage()    {}
func (*Quantity) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{10}
}

func (m *Quantity) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Quantity.Unmarshal(m, b)
}
func (m *Quantity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Quantity.Marshal(b, m, deterministic)
}
func (m *Quantity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Quantity.Merge(m, src)
}
func (m *Quantity) XXX_Size() int {
	return xxx_messageInfo_Quantity.Size(m)
}
func (m *Quantity) XXX_DiscardUnknown() {
	xxx_messageInfo_Quantity.DiscardUnknown(m)
}

var xxx_messageInfo_Quantity proto.InternalMessageInfo

func (m *Quantity) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type AllocationAsk struct {
	// Allocation key is used by both of scheduler and RM to track allocations.
	// It doesn't have to be same as RM's internal allocation id (such as Pod name of K8s or ContainerId of YARN).
	// Allocations from the same AllocationAsk which are returned to the RM at the same time will have the same allocationKey.
	// The request is considered an update of the existing AllocationAsk if an ALlocationAsk with the same allocationKey
	// already exists.
	AllocationKey string `protobuf:"bytes,1,opt,name=allocationKey,proto3" json:"allocationKey,omitempty"`
	// The application ID this allocation ask belongs to
	ApplicationId string `protobuf:"bytes,2,opt,name=applicationId,proto3" json:"applicationId,omitempty"`
	// The partition the application belongs to
	PartitionName string `protobuf:"bytes,3,opt,name=partitionName,proto3" json:"partitionName,omitempty"`
	// The amount of resources per ask
	ResourceAsk *Resource `protobuf:"bytes,4,opt,name=resourceAsk,proto3" json:"resourceAsk,omitempty"`
	// Maximum number of allocations
	MaxAllocations int32 `protobuf:"varint,5,opt,name=maxAllocations,proto3" json:"maxAllocations,omitempty"`
	// Priority of ask
	Priority *Priority `protobuf:"bytes,6,opt,name=priority,proto3" json:"priority,omitempty"`
	// Execution timeout: How long this allocation will be terminated (by scheduler)
	// once allocated by scheduler, 0 or negative value means never expire.
	ExecutionTimeoutMilliSeconds int64 `protobuf:"varint,7,opt,name=executionTimeoutMilliSeconds,proto3" json:"executionTimeoutMilliSeconds,omitempty"`
	// A set of tags for this spscific AllocationAsk. Allocation level tags are used in placing this specific
	// ask on nodes in the cluster. These tags are used in the PlacementConstraints.
	// These tags are optional.
	Tags map[string]string `protobuf:"bytes,8,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Placement constraint defines how this allocation should be placed in the cluster.
	// if not set, no placement constraint will be applied.
	PlacementConstraint  *PlacementConstraint `protobuf:"bytes,9,opt,name=placementConstraint,proto3" json:"placementConstraint,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *AllocationAsk) Reset()         { *m = AllocationAsk{} }
func (m *AllocationAsk) String() string { return proto.CompactTextString(m) }
func (*AllocationAsk) ProtoMessage()    {}
func (*AllocationAsk) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{11}
}

func (m *AllocationAsk) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AllocationAsk.Unmarshal(m, b)
}
func (m *AllocationAsk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AllocationAsk.Marshal(b, m, deterministic)
}
func (m *AllocationAsk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocationAsk.Merge(m, src)
}
func (m *AllocationAsk) XXX_Size() int {
	return xxx_messageInfo_AllocationAsk.Size(m)
}
func (m *AllocationAsk) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocationAsk.DiscardUnknown(m)
}

var xxx_messageInfo_AllocationAsk proto.InternalMessageInfo

func (m *AllocationAsk) GetAllocationKey() string {
	if m != nil {
		return m.AllocationKey
	}
	return ""
}

func (m *AllocationAsk) GetApplicationId() string {
	if m != nil {
		return m.ApplicationId
	}
	return ""
}

func (m *AllocationAsk) GetPartitionName() string {
	if m != nil {
		return m.PartitionName
	}
	return ""
}

func (m *AllocationAsk) GetResourceAsk() *Resource {
	if m != nil {
		return m.ResourceAsk
	}
	return nil
}

func (m *AllocationAsk) GetMaxAllocations() int32 {
	if m != nil {
		return m.MaxAllocations
	}
	return 0
}

func (m *AllocationAsk) GetPriority() *Priority {
	if m != nil {
		return m.Priority
	}
	return nil
}

func (m *AllocationAsk) GetExecutionTimeoutMilliSeconds() int64 {
	if m != nil {
		return m.ExecutionTimeoutMilliSeconds
	}
	return 0
}

func (m *AllocationAsk) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *AllocationAsk) GetPlacementConstraint() *PlacementConstraint {
	if m != nil {
		return m.PlacementConstraint
	}
	return nil
}

type AddApplicationRequest struct {
	// The ID of the application, must be unique
	ApplicationId string `protobuf:"bytes,1,opt,name=applicationId,proto3" json:"applicationId,omitempty"`
	// The queue this application is requesting. The scheduler will place the application into a
	// queue according to policy, taking into account the requested queue as per the policy.
	QueueName string `protobuf:"bytes,2,opt,name=queueName,proto3" json:"queueName,omitempty"`
	// The partition the application belongs to
	PartitionName string `protobuf:"bytes,3,opt,name=partitionName,proto3" json:"partitionName,omitempty"`
	// The user group information of the application owner
	Ugi *UserGroupInformation `protobuf:"bytes,4,opt,name=ugi,proto3" json:"ugi,omitempty"`
	// A set of tags for the application. These tags provide application level generic inforamtion.
	// The tags are optional and are used in placing an appliction or scheduling.
	// Application tags are not considered when processing AllocationAsks.
	Tags map[string]string `protobuf:"bytes,5,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Execution timeout: How long this application can be in a running state
	// 0 or negative value means never expire.
	ExecutionTimeoutMilliSeconds int64    `protobuf:"varint,6,opt,name=executionTimeoutMilliSeconds,proto3" json:"executionTimeoutMilliSeconds,omitempty"`
	XXX_NoUnkeyedLiteral         struct{} `json:"-"`
	XXX_unrecognized             []byte   `json:"-"`
	XXX_sizecache                int32    `json:"-"`
}

func (m *AddApplicationRequest) Reset()         { *m = AddApplicationRequest{} }
func (m *AddApplicationRequest) String() string { return proto.CompactTextString(m) }
func (*AddApplicationRequest) ProtoMessage()    {}
func (*AddApplicationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{12}
}

func (m *AddApplicationRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AddApplicationRequest.Unmarshal(m, b)
}
func (m *AddApplicationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AddApplicationRequest.Marshal(b, m, deterministic)
}
func (m *AddApplicationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddApplicationRequest.Merge(m, src)
}
func (m *AddApplicationRequest) XXX_Size() int {
	return xxx_messageInfo_AddApplicationRequest.Size(m)
}
func (m *AddApplicationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddApplicationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddApplicationRequest proto.InternalMessageInfo

func (m *AddApplicationRequest) GetApplicationId() string {
	if m != nil {
		return m.ApplicationId
	}
	return ""
}

func (m *AddApplicationRequest) GetQueueName() string {
	if m != nil {
		return m.QueueName
	}
	return ""
}

func (m *AddApplicationRequest) GetPartitionName() string {
	if m != nil {
		return m.PartitionName
	}
	return ""
}

func (m *AddApplicationRequest) GetUgi() *UserGroupInformation {
	if m != nil {
		return m.Ugi
	}
	return nil
}

func (m *AddApplicationRequest) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *AddApplicationRequest) GetExecutionTimeoutMilliSeconds() int64 {
	if m != nil {
		return m.ExecutionTimeoutMilliSeconds
	}
	return 0
}

type RemoveApplicationRequest struct {
	// The ID of the application to remove
	ApplicationId string `protobuf:"bytes,1,opt,name=applicationId,proto3" json:"applicationId,omitempty"`
	// The partition the application belongs to
	PartitionName        string   `protobuf:"bytes,2,opt,name=partitionName,proto3" json:"partitionName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoveApplicationRequest) Reset()         { *m = RemoveApplicationRequest{} }
func (m *RemoveApplicationRequest) String() string { return proto.CompactTextString(m) }
func (*RemoveApplicationRequest) ProtoMessage()    {}
func (*RemoveApplicationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{13}
}

func (m *RemoveApplicationRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RemoveApplicationRequest.Unmarshal(m, b)
}
func (m *RemoveApplicationRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RemoveApplicationRequest.Marshal(b, m, deterministic)
}
func (m *RemoveApplicationRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveApplicationRequest.Merge(m, src)
}
func (m *RemoveApplicationRequest) XXX_Size() int {
	return xxx_messageInfo_RemoveApplicationRequest.Size(m)
}
func (m *RemoveApplicationRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveApplicationRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveApplicationRequest proto.InternalMessageInfo

func (m *RemoveApplicationRequest) GetApplicationId() string {
	if m != nil {
		return m.ApplicationId
	}
	return ""
}

func (m *RemoveApplicationRequest) GetPartitionName() string {
	if m != nil {
		return m.PartitionName
	}
	return ""
}

type UserGroupInformation struct {
	// the user name
	User string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
	// the list of groups of the user, can be empty
	Groups               []string `protobuf:"bytes,2,rep,name=groups,proto3" json:"groups,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UserGroupInformation) Reset()         { *m = UserGroupInformation{} }
func (m *UserGroupInformation) String() string { return proto.CompactTextString(m) }
func (*UserGroupInformation) ProtoMessage()    {}
func (*UserGroupInformation) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{14}
}

func (m *UserGroupInformation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UserGroupInformation.Unmarshal(m, b)
}
func (m *UserGroupInformation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UserGroupInformation.Marshal(b, m, deterministic)
}
func (m *UserGroupInformation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserGroupInformation.Merge(m, src)
}
func (m *UserGroupInformation) XXX_Size() int {
	return xxx_messageInfo_UserGroupInformation.Size(m)
}
func (m *UserGroupInformation) XXX_DiscardUnknown() {
	xxx_messageInfo_UserGroupInformation.DiscardUnknown(m)
}

var xxx_messageInfo_UserGroupInformation proto.InternalMessageInfo

func (m *UserGroupInformation) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *UserGroupInformation) GetGroups() []string {
	if m != nil {
		return m.Groups
	}
	return nil
}

// PlacementConstraint could have simplePlacementConstraint or
// CompositePlacementConstraint. One of them will be set.
type PlacementConstraint struct {
	// Types that are valid to be assigned to Constraint:
	//	*PlacementConstraint_SimpleConstraint
	Constraint           isPlacementConstraint_Constraint `protobuf_oneof:"constraint"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *PlacementConstraint) Reset()         { *m = PlacementConstraint{} }
func (m *PlacementConstraint) String() string { return proto.CompactTextString(m) }
func (*PlacementConstraint) ProtoMessage()    {}
func (*PlacementConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{15}
}

func (m *PlacementConstraint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PlacementConstraint.Unmarshal(m, b)
}
func (m *PlacementConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PlacementConstraint.Marshal(b, m, deterministic)
}
func (m *PlacementConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlacementConstraint.Merge(m, src)
}
func (m *PlacementConstraint) XXX_Size() int {
	return xxx_messageInfo_PlacementConstraint.Size(m)
}
func (m *PlacementConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_PlacementConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_PlacementConstraint proto.InternalMessageInfo

type isPlacementConstraint_Constraint interface {
	isPlacementConstraint_Constraint()
}

type PlacementConstraint_SimpleConstraint struct {
	SimpleConstraint *SimplePlacementConstraint `protobuf:"bytes,1,opt,name=simpleConstraint,proto3,oneof"`
}

func (*PlacementConstraint_SimpleConstraint) isPlacementConstraint_Constraint() {}

func (m *PlacementConstraint) GetConstraint() isPlacementConstraint_Constraint {
	if m != nil {
		return m.Constraint
	}
	return nil
}

func (m *PlacementConstraint) GetSimpleConstraint() *SimplePlacementConstraint {
	if x, ok := m.GetConstraint().(*PlacementConstraint_SimpleConstraint); ok {
		return x.SimpleConstraint
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PlacementConstraint) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PlacementConstraint_SimpleConstraint)(nil),
	}
}

// Simple placement constraint represent constraint for affinity/anti-affinity
// to node attribute or allocation tags.
// When both of NodeAffinityConstraints and AllocationAffinityConstraints
// specified, both will be checked and verified while scheduling.
type SimplePlacementConstraint struct {
	// Constraint
	NodeAffinityConstraint      *NodeAffinityConstraints       `protobuf:"bytes,1,opt,name=nodeAffinityConstraint,proto3" json:"nodeAffinityConstraint,omitempty"`
	AllocationAffinityAttribute *AllocationAffinityConstraints `protobuf:"bytes,2,opt,name=allocationAffinityAttribute,proto3" json:"allocationAffinityAttribute,omitempty"`
	XXX_NoUnkeyedLiteral        struct{}                       `json:"-"`
	XXX_unrecognized            []byte                         `json:"-"`
	XXX_sizecache               int32                          `json:"-"`
}

func (m *SimplePlacementConstraint) Reset()         { *m = SimplePlacementConstraint{} }
func (m *SimplePlacementConstraint) String() string { return proto.CompactTextString(m) }
func (*SimplePlacementConstraint) ProtoMessage()    {}
func (*SimplePlacementConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{16}
}

func (m *SimplePlacementConstraint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SimplePlacementConstraint.Unmarshal(m, b)
}
func (m *SimplePlacementConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SimplePlacementConstraint.Marshal(b, m, deterministic)
}
func (m *SimplePlacementConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimplePlacementConstraint.Merge(m, src)
}
func (m *SimplePlacementConstraint) XXX_Size() int {
	return xxx_messageInfo_SimplePlacementConstraint.Size(m)
}
func (m *SimplePlacementConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_SimplePlacementConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_SimplePlacementConstraint proto.InternalMessageInfo

func (m *SimplePlacementConstraint) GetNodeAffinityConstraint() *NodeAffinityConstraints {
	if m != nil {
		return m.NodeAffinityConstraint
	}
	return nil
}

func (m *SimplePlacementConstraint) GetAllocationAffinityAttribute() *AllocationAffinityConstraints {
	if m != nil {
		return m.AllocationAffinityAttribute
	}
	return nil
}

// Affinity to node, multiple AffinityTargetExpression will be specified,
// They will be connected by AND.
type NodeAffinityConstraints struct {
	TargetExpressions    []*AffinityTargetExpression `protobuf:"bytes,2,rep,name=targetExpressions,proto3" json:"targetExpressions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *NodeAffinityConstraints) Reset()         { *m = NodeAffinityConstraints{} }
func (m *NodeAffinityConstraints) String() string { return proto.CompactTextString(m) }
func (*NodeAffinityConstraints) ProtoMessage()    {}
func (*NodeAffinityConstraints) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{17}
}

func (m *NodeAffinityConstraints) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeAffinityConstraints.Unmarshal(m, b)
}
func (m *NodeAffinityConstraints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeAffinityConstraints.Marshal(b, m, deterministic)
}
func (m *NodeAffinityConstraints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeAffinityConstraints.Merge(m, src)
}
func (m *NodeAffinityConstraints) XXX_Size() int {
	return xxx_messageInfo_NodeAffinityConstraints.Size(m)
}
func (m *NodeAffinityConstraints) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeAffinityConstraints.DiscardUnknown(m)
}

var xxx_messageInfo_NodeAffinityConstraints proto.InternalMessageInfo

func (m *NodeAffinityConstraints) GetTargetExpressions() []*AffinityTargetExpression {
	if m != nil {
		return m.TargetExpressions
	}
	return nil
}

// Affinity to allocations (containers).
// Affinity is single-direction, which means if RM wants to do mutual affinity/
// anti-affinity between allocations, same constraints need to be added
// to all allocation asks.
type AllocationAffinityConstraints struct {
	// Scope: scope is key of node attribute, which determines if >1 allocations
	// in the same group or not.
	// When allocations on node(s) which have same node attribute value
	// for given node attribute key == scope. They're in the same group.
	//
	// e.g. when user wants to do anti-affinity between allocation on node
	// basis, scope can be set to "hostname", max-cardinality = 1;
	Scope             string                      `protobuf:"bytes,1,opt,name=scope,proto3" json:"scope,omitempty"`
	TragetExpressions []*AffinityTargetExpression `protobuf:"bytes,2,rep,name=tragetExpressions,proto3" json:"tragetExpressions,omitempty"`
	MinCardinality    int32                       `protobuf:"varint,3,opt,name=minCardinality,proto3" json:"minCardinality,omitempty"`
	MaxCardinality    int32                       `protobuf:"varint,4,opt,name=maxCardinality,proto3" json:"maxCardinality,omitempty"`
	// Is this a required (hard) or preferred (soft) request.
	Required             bool     `protobuf:"varint,5,opt,name=required,proto3" json:"required,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AllocationAffinityConstraints) Reset()         { *m = AllocationAffinityConstraints{} }
func (m *AllocationAffinityConstraints) String() string { return proto.CompactTextString(m) }
func (*AllocationAffinityConstraints) ProtoMessage()    {}
func (*AllocationAffinityConstraints) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{18}
}

func (m *AllocationAffinityConstraints) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AllocationAffinityConstraints.Unmarshal(m, b)
}
func (m *AllocationAffinityConstraints) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AllocationAffinityConstraints.Marshal(b, m, deterministic)
}
func (m *AllocationAffinityConstraints) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocationAffinityConstraints.Merge(m, src)
}
func (m *AllocationAffinityConstraints) XXX_Size() int {
	return xxx_messageInfo_AllocationAffinityConstraints.Size(m)
}
func (m *AllocationAffinityConstraints) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocationAffinityConstraints.DiscardUnknown(m)
}

var xxx_messageInfo_AllocationAffinityConstraints proto.InternalMessageInfo

func (m *AllocationAffinityConstraints) GetScope() string {
	if m != nil {
		return m.Scope
	}
	return ""
}

func (m *AllocationAffinityConstraints) GetTragetExpressions() []*AffinityTargetExpression {
	if m != nil {
		return m.TragetExpressions
	}
	return nil
}

func (m *AllocationAffinityConstraints) GetMinCardinality() int32 {
	if m != nil {
		return m.MinCardinality
	}
	return 0
}

func (m *AllocationAffinityConstraints) GetMaxCardinality() int32 {
	if m != nil {
		return m.MaxCardinality
	}
	return 0
}

func (m *AllocationAffinityConstraints) GetRequired() bool {
	if m != nil {
		return m.Required
	}
	return false
}

type AffinityTargetExpression struct {
	TargetOperator       *AffinityTargetExpression `protobuf:"bytes,1,opt,name=targetOperator,proto3" json:"targetOperator,omitempty"`
	TargetKey            string                    `protobuf:"bytes,2,opt,name=targetKey,proto3" json:"targetKey,omitempty"`
	TargetValues         []string                  `protobuf:"bytes,3,rep,name=targetValues,proto3" json:"targetValues,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *AffinityTargetExpression) Reset()         { *m = AffinityTargetExpression{} }
func (m *AffinityTargetExpression) String() string { return proto.CompactTextString(m) }
func (*AffinityTargetExpression) ProtoMessage()    {}
func (*AffinityTargetExpression) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{19}
}

func (m *AffinityTargetExpression) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AffinityTargetExpression.Unmarshal(m, b)
}
func (m *AffinityTargetExpression) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AffinityTargetExpression.Marshal(b, m, deterministic)
}
func (m *AffinityTargetExpression) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AffinityTargetExpression.Merge(m, src)
}
func (m *AffinityTargetExpression) XXX_Size() int {
	return xxx_messageInfo_AffinityTargetExpression.Size(m)
}
func (m *AffinityTargetExpression) XXX_DiscardUnknown() {
	xxx_messageInfo_AffinityTargetExpression.DiscardUnknown(m)
}

var xxx_messageInfo_AffinityTargetExpression proto.InternalMessageInfo

func (m *AffinityTargetExpression) GetTargetOperator() *AffinityTargetExpression {
	if m != nil {
		return m.TargetOperator
	}
	return nil
}

func (m *AffinityTargetExpression) GetTargetKey() string {
	if m != nil {
		return m.TargetKey
	}
	return ""
}

func (m *AffinityTargetExpression) GetTargetValues() []string {
	if m != nil {
		return m.TargetValues
	}
	return nil
}

type AllocationReleasesRequest struct {
	// The allocations to release
	AllocationsToRelease []*AllocationReleaseRequest `protobuf:"bytes,1,rep,name=allocationsToRelease,proto3" json:"allocationsToRelease,omitempty"`
	// The asks to release
	AllocationAsksToRelease []*AllocationAskReleaseRequest `protobuf:"bytes,2,rep,name=allocationAsksToRelease,proto3" json:"allocationAsksToRelease,omitempty"`
	XXX_NoUnkeyedLiteral    struct{}                       `json:"-"`
	XXX_unrecognized        []byte                         `json:"-"`
	XXX_sizecache           int32                          `json:"-"`
}

func (m *AllocationReleasesRequest) Reset()         { *m = AllocationReleasesRequest{} }
func (m *AllocationReleasesRequest) String() string { return proto.CompactTextString(m) }
func (*AllocationReleasesRequest) ProtoMessage()    {}
func (*AllocationReleasesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{20}
}

func (m *AllocationReleasesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AllocationReleasesRequest.Unmarshal(m, b)
}
func (m *AllocationReleasesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AllocationReleasesRequest.Marshal(b, m, deterministic)
}
func (m *AllocationReleasesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocationReleasesRequest.Merge(m, src)
}
func (m *AllocationReleasesRequest) XXX_Size() int {
	return xxx_messageInfo_AllocationReleasesRequest.Size(m)
}
func (m *AllocationReleasesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocationReleasesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AllocationReleasesRequest proto.InternalMessageInfo

func (m *AllocationReleasesRequest) GetAllocationsToRelease() []*AllocationReleaseRequest {
	if m != nil {
		return m.AllocationsToRelease
	}
	return nil
}

func (m *AllocationReleasesRequest) GetAllocationAsksToRelease() []*AllocationAskReleaseRequest {
	if m != nil {
		return m.AllocationAsksToRelease
	}
	return nil
}

// Release allocation
type AllocationReleaseRequest struct {
	// Which partition to release the allocation from, required.
	PartitionName string `protobuf:"bytes,1,opt,name=partitionName,proto3" json:"partitionName,omitempty"`
	// optional, when this is set, filter allocations by application id.
	// when application id is set and uuid is not set, release all allocations under the application id.
	ApplicationId string `protobuf:"bytes,2,opt,name=applicationId,proto3" json:"applicationId,omitempty"`
	// optional, when this is set, only release allocation by given uuid.
	Uuid string `protobuf:"bytes,3,opt,name=uuid,proto3" json:"uuid,omitempty"`
	// For human-readable message
	Message              string   `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AllocationReleaseRequest) Reset()         { *m = AllocationReleaseRequest{} }
func (m *AllocationReleaseRequest) String() string { return proto.CompactTextString(m) }
func (*AllocationReleaseRequest) ProtoMessage()    {}
func (*AllocationReleaseRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{21}
}

func (m *AllocationReleaseRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AllocationReleaseRequest.Unmarshal(m, b)
}
func (m *AllocationReleaseRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AllocationReleaseRequest.Marshal(b, m, deterministic)
}
func (m *AllocationReleaseRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocationReleaseRequest.Merge(m, src)
}
func (m *AllocationReleaseRequest) XXX_Size() int {
	return xxx_messageInfo_AllocationReleaseRequest.Size(m)
}
func (m *AllocationReleaseRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocationReleaseRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AllocationReleaseRequest proto.InternalMessageInfo

func (m *AllocationReleaseRequest) GetPartitionName() string {
	if m != nil {
		return m.PartitionName
	}
	return ""
}

func (m *AllocationReleaseRequest) GetApplicationId() string {
	if m != nil {
		return m.ApplicationId
	}
	return ""
}

func (m *AllocationReleaseRequest) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *AllocationReleaseRequest) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Release ask
type AllocationAskReleaseRequest struct {
	// Which partition to release the ask from, required.
	PartitionName string `protobuf:"bytes,1,opt,name=partitionName,proto3" json:"partitionName,omitempty"`
	// optional, when this is set, filter allocation key by application id.
	// when application id is set and allocationKey is not set, release all allocations key under the application id.
	ApplicationId string `protobuf:"bytes,2,opt,name=applicationId,proto3" json:"applicationId,omitempty"`
	// optional, when this is set, only release allocation ask by specified
	Allocationkey string `protobuf:"bytes,3,opt,name=allocationkey,proto3" json:"allocationkey,omitempty"`
	// For human-readable message
	Message              string   `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AllocationAskReleaseRequest) Reset()         { *m = AllocationAskReleaseRequest{} }
func (m *AllocationAskReleaseRequest) String() string { return proto.CompactTextString(m) }
func (*AllocationAskReleaseRequest) ProtoMessage()    {}
func (*AllocationAskReleaseRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{22}
}

func (m *AllocationAskReleaseRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AllocationAskReleaseRequest.Unmarshal(m, b)
}
func (m *AllocationAskReleaseRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AllocationAskReleaseRequest.Marshal(b, m, deterministic)
}
func (m *AllocationAskReleaseRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocationAskReleaseRequest.Merge(m, src)
}
func (m *AllocationAskReleaseRequest) XXX_Size() int {
	return xxx_messageInfo_AllocationAskReleaseRequest.Size(m)
}
func (m *AllocationAskReleaseRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocationAskReleaseRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AllocationAskReleaseRequest proto.InternalMessageInfo

func (m *AllocationAskReleaseRequest) GetPartitionName() string {
	if m != nil {
		return m.PartitionName
	}
	return ""
}

func (m *AllocationAskReleaseRequest) GetApplicationId() string {
	if m != nil {
		return m.ApplicationId
	}
	return ""
}

func (m *AllocationAskReleaseRequest) GetAllocationkey() string {
	if m != nil {
		return m.Allocationkey
	}
	return ""
}

func (m *AllocationAskReleaseRequest) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type NewNodeInfo struct {
	// Id of node, must be unique
	NodeId string `protobuf:"bytes,1,opt,name=nodeId,proto3" json:"nodeId,omitempty"`
	// node attributes
	Attributes map[string]string `protobuf:"bytes,2,rep,name=attributes,proto3" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Schedulable Resource
	SchedulableResource *Resource `protobuf:"bytes,3,opt,name=schedulableResource,proto3" json:"schedulableResource,omitempty"`
	// Allocated resources, this will be added when node registered to RM (recovery)
	ExistingAllocations  []*Allocation `protobuf:"bytes,4,rep,name=existingAllocations,proto3" json:"existingAllocations,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *NewNodeInfo) Reset()         { *m = NewNodeInfo{} }
func (m *NewNodeInfo) String() string { return proto.CompactTextString(m) }
func (*NewNodeInfo) ProtoMessage()    {}
func (*NewNodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{23}
}

func (m *NewNodeInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NewNodeInfo.Unmarshal(m, b)
}
func (m *NewNodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NewNodeInfo.Marshal(b, m, deterministic)
}
func (m *NewNodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewNodeInfo.Merge(m, src)
}
func (m *NewNodeInfo) XXX_Size() int {
	return xxx_messageInfo_NewNodeInfo.Size(m)
}
func (m *NewNodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NewNodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NewNodeInfo proto.InternalMessageInfo

func (m *NewNodeInfo) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *NewNodeInfo) GetAttributes() map[string]string {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *NewNodeInfo) GetSchedulableResource() *Resource {
	if m != nil {
		return m.SchedulableResource
	}
	return nil
}

func (m *NewNodeInfo) GetExistingAllocations() []*Allocation {
	if m != nil {
		return m.ExistingAllocations
	}
	return nil
}

type UpdateNodeInfo struct {
	// Id of node, the node must exist to be updated
	NodeId string `protobuf:"bytes,1,opt,name=nodeId,proto3" json:"nodeId,omitempty"`
	// New attributes of node, which will replace previously reported attribute.
	Attributes map[string]string `protobuf:"bytes,2,rep,name=attributes,proto3" json:"attributes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// new schedulable resource, scheduler may preempt allocations on the
	// node or schedule more allocations accordingly.
	SchedulableResource *Resource `protobuf:"bytes,3,opt,name=schedulableResource,proto3" json:"schedulableResource,omitempty"`
	// Action to perform by the scheduler
	Action               UpdateNodeInfo_ActionFromRM `protobuf:"varint,4,opt,name=action,proto3,enum=si.v1.UpdateNodeInfo_ActionFromRM" json:"action,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *UpdateNodeInfo) Reset()         { *m = UpdateNodeInfo{} }
func (m *UpdateNodeInfo) String() string { return proto.CompactTextString(m) }
func (*UpdateNodeInfo) ProtoMessage()    {}
func (*UpdateNodeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{24}
}

func (m *UpdateNodeInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UpdateNodeInfo.Unmarshal(m, b)
}
func (m *UpdateNodeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UpdateNodeInfo.Marshal(b, m, deterministic)
}
func (m *UpdateNodeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateNodeInfo.Merge(m, src)
}
func (m *UpdateNodeInfo) XXX_Size() int {
	return xxx_messageInfo_UpdateNodeInfo.Size(m)
}
func (m *UpdateNodeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateNodeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateNodeInfo proto.InternalMessageInfo

func (m *UpdateNodeInfo) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *UpdateNodeInfo) GetAttributes() map[string]string {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *UpdateNodeInfo) GetSchedulableResource() *Resource {
	if m != nil {
		return m.SchedulableResource
	}
	return nil
}

func (m *UpdateNodeInfo) GetAction() UpdateNodeInfo_ActionFromRM {
	if m != nil {
		return m.Action
	}
	return UpdateNodeInfo_DRAIN_NODE
}

type UtilizationReport struct {
	// it could be either node id or allocation uuid.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Actual used resource
	ActualUsedResource   *Resource `protobuf:"bytes,2,opt,name=actualUsedResource,proto3" json:"actualUsedResource,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *UtilizationReport) Reset()         { *m = UtilizationReport{} }
func (m *UtilizationReport) String() string { return proto.CompactTextString(m) }
func (*UtilizationReport) ProtoMessage()    {}
func (*UtilizationReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{25}
}

func (m *UtilizationReport) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UtilizationReport.Unmarshal(m, b)
}
func (m *UtilizationReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UtilizationReport.Marshal(b, m, deterministic)
}
func (m *UtilizationReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UtilizationReport.Merge(m, src)
}
func (m *UtilizationReport) XXX_Size() int {
	return xxx_messageInfo_UtilizationReport.Size(m)
}
func (m *UtilizationReport) XXX_DiscardUnknown() {
	xxx_messageInfo_UtilizationReport.DiscardUnknown(m)
}

var xxx_messageInfo_UtilizationReport proto.InternalMessageInfo

func (m *UtilizationReport) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *UtilizationReport) GetActualUsedResource() *Resource {
	if m != nil {
		return m.ActualUsedResource
	}
	return nil
}

type Allocation struct {
	// AllocationKey from AllocationAsk
	AllocationKey string `protobuf:"bytes,1,opt,name=allocationKey,proto3" json:"allocationKey,omitempty"`
	// Allocation tags from AllocationAsk
	AllocationTags map[string]string `protobuf:"bytes,2,rep,name=allocationTags,proto3" json:"allocationTags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// uuid of the allocation
	Uuid string `protobuf:"bytes,3,opt,name=uuid,proto3" json:"uuid,omitempty"`
	// Resource for each allocation
	ResourcePerAlloc *Resource `protobuf:"bytes,5,opt,name=resourcePerAlloc,proto3" json:"resourcePerAlloc,omitempty"`
	// Priority of ask
	Priority *Priority `protobuf:"bytes,6,opt,name=priority,proto3" json:"priority,omitempty"`
	// Queue which the allocation belongs to
	QueueName string `protobuf:"bytes,7,opt,name=queueName,proto3" json:"queueName,omitempty"`
	// Node which the allocation belongs to
	NodeId string `protobuf:"bytes,8,opt,name=nodeId,proto3" json:"nodeId,omitempty"`
	// The ID of the application
	ApplicationId string `protobuf:"bytes,9,opt,name=applicationId,proto3" json:"applicationId,omitempty"`
	// Partition of the allocation
	PartitionName        string   `protobuf:"bytes,10,opt,name=partitionName,proto3" json:"partitionName,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Allocation) Reset()         { *m = Allocation{} }
func (m *Allocation) String() string { return proto.CompactTextString(m) }
func (*Allocation) ProtoMessage()    {}
func (*Allocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{26}
}

func (m *Allocation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Allocation.Unmarshal(m, b)
}
func (m *Allocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Allocation.Marshal(b, m, deterministic)
}
func (m *Allocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Allocation.Merge(m, src)
}
func (m *Allocation) XXX_Size() int {
	return xxx_messageInfo_Allocation.Size(m)
}
func (m *Allocation) XXX_DiscardUnknown() {
	xxx_messageInfo_Allocation.DiscardUnknown(m)
}

var xxx_messageInfo_Allocation proto.InternalMessageInfo

func (m *Allocation) GetAllocationKey() string {
	if m != nil {
		return m.AllocationKey
	}
	return ""
}

func (m *Allocation) GetAllocationTags() map[string]string {
	if m != nil {
		return m.AllocationTags
	}
	return nil
}

func (m *Allocation) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *Allocation) GetResourcePerAlloc() *Resource {
	if m != nil {
		return m.ResourcePerAlloc
	}
	return nil
}

func (m *Allocation) GetPriority() *Priority {
	if m != nil {
		return m.Priority
	}
	return nil
}

func (m *Allocation) GetQueueName() string {
	if m != nil {
		return m.QueueName
	}
	return ""
}

func (m *Allocation) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *Allocation) GetApplicationId() string {
	if m != nil {
		return m.ApplicationId
	}
	return ""
}

func (m *Allocation) GetPartitionName() string {
	if m != nil {
		return m.PartitionName
	}
	return ""
}

type RejectedAllocationAsk struct {
	AllocationKey string `protobuf:"bytes,1,opt,name=allocationKey,proto3" json:"allocationKey,omitempty"`
	// The ID of the application
	ApplicationId string `protobuf:"bytes,2,opt,name=applicationId,proto3" json:"applicationId,omitempty"`
	// A human-readable reason message
	Reason               string   `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RejectedAllocationAsk) Reset()         { *m = RejectedAllocationAsk{} }
func (m *RejectedAllocationAsk) String() string { return proto.CompactTextString(m) }
func (*RejectedAllocationAsk) ProtoMessage()    {}
func (*RejectedAllocationAsk) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{27}
}

func (m *RejectedAllocationAsk) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RejectedAllocationAsk.Unmarshal(m, b)
}
func (m *RejectedAllocationAsk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RejectedAllocationAsk.Marshal(b, m, deterministic)
}
func (m *RejectedAllocationAsk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RejectedAllocationAsk.Merge(m, src)
}
func (m *RejectedAllocationAsk) XXX_Size() int {
	return xxx_messageInfo_RejectedAllocationAsk.Size(m)
}
func (m *RejectedAllocationAsk) XXX_DiscardUnknown() {
	xxx_messageInfo_RejectedAllocationAsk.DiscardUnknown(m)
}

var xxx_messageInfo_RejectedAllocationAsk proto.InternalMessageInfo

func (m *RejectedAllocationAsk) GetAllocationKey() string {
	if m != nil {
		return m.AllocationKey
	}
	return ""
}

func (m *RejectedAllocationAsk) GetApplicationId() string {
	if m != nil {
		return m.ApplicationId
	}
	return ""
}

func (m *RejectedAllocationAsk) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type NodeRecommendation struct {
	RecommendedSchedulableResource *Resource `protobuf:"bytes,1,opt,name=recommendedSchedulableResource,proto3" json:"recommendedSchedulableResource,omitempty"`
	// Any other human-readable message
	Message              string   `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeRecommendation) Reset()         { *m = NodeRecommendation{} }
func (m *NodeRecommendation) String() string { return proto.CompactTextString(m) }
func (*NodeRecommendation) ProtoMessage()    {}
func (*NodeRecommendation) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{28}
}

func (m *NodeRecommendation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeRecommendation.Unmarshal(m, b)
}
func (m *NodeRecommendation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeRecommendation.Marshal(b, m, deterministic)
}
func (m *NodeRecommendation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeRecommendation.Merge(m, src)
}
func (m *NodeRecommendation) XXX_Size() int {
	return xxx_messageInfo_NodeRecommendation.Size(m)
}
func (m *NodeRecommendation) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeRecommendation.DiscardUnknown(m)
}

var xxx_messageInfo_NodeRecommendation proto.InternalMessageInfo

func (m *NodeRecommendation) GetRecommendedSchedulableResource() *Resource {
	if m != nil {
		return m.RecommendedSchedulableResource
	}
	return nil
}

func (m *NodeRecommendation) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// When allocation released, either by RM or preempted by scheduler. It will be sent back to RM.
type AllocationReleaseResponse struct {
	// UUID of the allocation that is released
	Uuid string `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	// Termination type of the released allocation
	TerminationType AllocationReleaseResponse_TerminationType `protobuf:"varint,2,opt,name=terminationType,proto3,enum=si.v1.AllocationReleaseResponse_TerminationType" json:"terminationType,omitempty"`
	// Any other human-readable message
	Message              string   `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AllocationReleaseResponse) Reset()         { *m = AllocationReleaseResponse{} }
func (m *AllocationReleaseResponse) String() string { return proto.CompactTextString(m) }
func (*AllocationReleaseResponse) ProtoMessage()    {}
func (*AllocationReleaseResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{29}
}

func (m *AllocationReleaseResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AllocationReleaseResponse.Unmarshal(m, b)
}
func (m *AllocationReleaseResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AllocationReleaseResponse.Marshal(b, m, deterministic)
}
func (m *AllocationReleaseResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocationReleaseResponse.Merge(m, src)
}
func (m *AllocationReleaseResponse) XXX_Size() int {
	return xxx_messageInfo_AllocationReleaseResponse.Size(m)
}
func (m *AllocationReleaseResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocationReleaseResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AllocationReleaseResponse proto.InternalMessageInfo

func (m *AllocationReleaseResponse) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *AllocationReleaseResponse) GetTerminationType() AllocationReleaseResponse_TerminationType {
	if m != nil {
		return m.TerminationType
	}
	return AllocationReleaseResponse_STOPPED_BY_RM
}

func (m *AllocationReleaseResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type PredicatesArgs struct {
	// allocation key identifies a container, the predicates function is going to check
	// if this container is eligible to be placed ont to a node.
	AllocationKey string `protobuf:"bytes,1,opt,name=allocationKey,proto3" json:"allocationKey,omitempty"`
	// the node ID the container is assigned to.
	NodeId               string   `protobuf:"bytes,2,opt,name=nodeId,proto3" json:"nodeId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PredicatesArgs) Reset()         { *m = PredicatesArgs{} }
func (m *PredicatesArgs) String() string { return proto.CompactTextString(m) }
func (*PredicatesArgs) ProtoMessage()    {}
func (*PredicatesArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{30}
}

func (m *PredicatesArgs) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PredicatesArgs.Unmarshal(m, b)
}
func (m *PredicatesArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PredicatesArgs.Marshal(b, m, deterministic)
}
func (m *PredicatesArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PredicatesArgs.Merge(m, src)
}
func (m *PredicatesArgs) XXX_Size() int {
	return xxx_messageInfo_PredicatesArgs.Size(m)
}
func (m *PredicatesArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_PredicatesArgs.DiscardUnknown(m)
}

var xxx_messageInfo_PredicatesArgs proto.InternalMessageInfo

func (m *PredicatesArgs) GetAllocationKey() string {
	if m != nil {
		return m.AllocationKey
	}
	return ""
}

func (m *PredicatesArgs) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

type ReSyncSchedulerCacheArgs struct {
	// a list of assumed allocations, this will be sync'd to scheduler cache.
	AssumedAllocations   []*AssumedAllocation `protobuf:"bytes,1,rep,name=assumedAllocations,proto3" json:"assumedAllocations,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ReSyncSchedulerCacheArgs) Reset()         { *m = ReSyncSchedulerCacheArgs{} }
func (m *ReSyncSchedulerCacheArgs) String() string { return proto.CompactTextString(m) }
func (*ReSyncSchedulerCacheArgs) ProtoMessage()    {}
func (*ReSyncSchedulerCacheArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{31}
}

func (m *ReSyncSchedulerCacheArgs) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReSyncSchedulerCacheArgs.Unmarshal(m, b)
}
func (m *ReSyncSchedulerCacheArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReSyncSchedulerCacheArgs.Marshal(b, m, deterministic)
}
func (m *ReSyncSchedulerCacheArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReSyncSchedulerCacheArgs.Merge(m, src)
}
func (m *ReSyncSchedulerCacheArgs) XXX_Size() int {
	return xxx_messageInfo_ReSyncSchedulerCacheArgs.Size(m)
}
func (m *ReSyncSchedulerCacheArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_ReSyncSchedulerCacheArgs.DiscardUnknown(m)
}

var xxx_messageInfo_ReSyncSchedulerCacheArgs proto.InternalMessageInfo

func (m *ReSyncSchedulerCacheArgs) GetAssumedAllocations() []*AssumedAllocation {
	if m != nil {
		return m.AssumedAllocations
	}
	return nil
}

type AssumedAllocation struct {
	// allocation key used to identify a container.
	AllocationKey string `protobuf:"bytes,1,opt,name=allocationKey,proto3" json:"allocationKey,omitempty"`
	// the node ID the container is assumed to be allocated to, this info is stored in scheduler cache.
	NodeId               string   `protobuf:"bytes,2,opt,name=nodeId,proto3" json:"nodeId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AssumedAllocation) Reset()         { *m = AssumedAllocation{} }
func (m *AssumedAllocation) String() string { return proto.CompactTextString(m) }
func (*AssumedAllocation) ProtoMessage()    {}
func (*AssumedAllocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc4a0b9b2d5549ed, []int{32}
}

func (m *AssumedAllocation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AssumedAllocation.Unmarshal(m, b)
}
func (m *AssumedAllocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AssumedAllocation.Marshal(b, m, deterministic)
}
func (m *AssumedAllocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssumedAllocation.Merge(m, src)
}
func (m *AssumedAllocation) XXX_Size() int {
	return xxx_messageInfo_AssumedAllocation.Size(m)
}
func (m *AssumedAllocation) XXX_DiscardUnknown() {
	xxx_messageInfo_AssumedAllocation.DiscardUnknown(m)
}

var xxx_messageInfo_AssumedAllocation proto.InternalMessageInfo

func (m *AssumedAllocation) GetAllocationKey() string {
	if m != nil {
		return m.AllocationKey
	}
	return ""
}

func (m *AssumedAllocation) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

var E_SiSecret = &proto.ExtensionDesc{
	ExtendedType:  (*descriptor.FieldOptions)(nil),
	ExtensionType: (*bool)(nil),
	Field:         1059,
	Name:          "si.v1.si_secret",
	Tag:           "varint,1059,opt,name=si_secret",
	Filename:      "yunikorn-scheduler-interface/si.proto",
}

func init() {
	proto.RegisterEnum("si.v1.UpdateResponse_ActionFromScheduler", UpdateResponse_ActionFromScheduler_name, UpdateResponse_ActionFromScheduler_value)
	proto.RegisterEnum("si.v1.AffinityTargetExpression_AffinityTargetOperator", AffinityTargetExpression_AffinityTargetOperator_name, AffinityTargetExpression_AffinityTargetOperator_value)
	proto.RegisterEnum("si.v1.UpdateNodeInfo_ActionFromRM", UpdateNodeInfo_ActionFromRM_name, UpdateNodeInfo_ActionFromRM_value)
	proto.RegisterEnum("si.v1.AllocationReleaseResponse_TerminationType", AllocationReleaseResponse_TerminationType_name, AllocationReleaseResponse_TerminationType_value)
	proto.RegisterType((*RegisterResourceManagerRequest)(nil), "si.v1.RegisterResourceManagerRequest")
	proto.RegisterType((*RegisterResourceManagerResponse)(nil), "si.v1.RegisterResourceManagerResponse")
	proto.RegisterType((*UpdateRequest)(nil), "si.v1.UpdateRequest")
	proto.RegisterType((*UpdateResponse)(nil), "si.v1.UpdateResponse")
	proto.RegisterType((*RejectedApplication)(nil), "si.v1.RejectedApplication")
	proto.RegisterType((*AcceptedApplication)(nil), "si.v1.AcceptedApplication")
	proto.RegisterType((*RejectedNode)(nil), "si.v1.RejectedNode")
	proto.RegisterType((*AcceptedNode)(nil), "si.v1.AcceptedNode")
	proto.RegisterType((*Priority)(nil), "si.v1.Priority")
	proto.RegisterType((*Resource)(nil), "si.v1.Resource")
	proto.RegisterMapType((map[string]*Quantity)(nil), "si.v1.Resource.ResourcesEntry")
	proto.RegisterType((*Quantity)(nil), "si.v1.Quantity")
	proto.RegisterType((*AllocationAsk)(nil), "si.v1.AllocationAsk")
	proto.RegisterMapType((map[string]string)(nil), "si.v1.AllocationAsk.TagsEntry")
	proto.RegisterType((*AddApplicationRequest)(nil), "si.v1.AddApplicationRequest")
	proto.RegisterMapType((map[string]string)(nil), "si.v1.AddApplicationRequest.TagsEntry")
	proto.RegisterType((*RemoveApplicationRequest)(nil), "si.v1.RemoveApplicationRequest")
	proto.RegisterType((*UserGroupInformation)(nil), "si.v1.UserGroupInformation")
	proto.RegisterType((*PlacementConstraint)(nil), "si.v1.PlacementConstraint")
	proto.RegisterType((*SimplePlacementConstraint)(nil), "si.v1.SimplePlacementConstraint")
	proto.RegisterType((*NodeAffinityConstraints)(nil), "si.v1.NodeAffinityConstraints")
	proto.RegisterType((*AllocationAffinityConstraints)(nil), "si.v1.AllocationAffinityConstraints")
	proto.RegisterType((*AffinityTargetExpression)(nil), "si.v1.AffinityTargetExpression")
	proto.RegisterType((*AllocationReleasesRequest)(nil), "si.v1.AllocationReleasesRequest")
	proto.RegisterType((*AllocationReleaseRequest)(nil), "si.v1.AllocationReleaseRequest")
	proto.RegisterType((*AllocationAskReleaseRequest)(nil), "si.v1.AllocationAskReleaseRequest")
	proto.RegisterType((*NewNodeInfo)(nil), "si.v1.NewNodeInfo")
	proto.RegisterMapType((map[string]string)(nil), "si.v1.NewNodeInfo.AttributesEntry")
	proto.RegisterType((*UpdateNodeInfo)(nil), "si.v1.UpdateNodeInfo")
	proto.RegisterMapType((map[string]string)(nil), "si.v1.UpdateNodeInfo.AttributesEntry")
	proto.RegisterType((*UtilizationReport)(nil), "si.v1.UtilizationReport")
	proto.RegisterType((*Allocation)(nil), "si.v1.Allocation")
	proto.RegisterMapType((map[string]string)(nil), "si.v1.Allocation.AllocationTagsEntry")
	proto.RegisterType((*RejectedAllocationAsk)(nil), "si.v1.RejectedAllocationAsk")
	proto.RegisterType((*NodeRecommendation)(nil), "si.v1.NodeRecommendation")
	proto.RegisterType((*AllocationReleaseResponse)(nil), "si.v1.AllocationReleaseResponse")
	proto.RegisterType((*PredicatesArgs)(nil), "si.v1.PredicatesArgs")
	proto.RegisterType((*ReSyncSchedulerCacheArgs)(nil), "si.v1.ReSyncSchedulerCacheArgs")
	proto.RegisterType((*AssumedAllocation)(nil), "si.v1.AssumedAllocation")
	proto.RegisterExtension(E_SiSecret)
}

func init() {
	proto.RegisterFile("yunikorn-scheduler-interface/si.proto", fileDescriptor_fc4a0b9b2d5549ed)
}

var fileDescriptor_fc4a0b9b2d5549ed = []byte{
	// 2041 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x59, 0xcd, 0x72, 0xdb, 0xc8,
	0x11, 0x16, 0x48, 0x4a, 0x22, 0x5b, 0x12, 0x45, 0x0d, 0x65, 0x2f, 0x2d, 0x7b, 0x65, 0x05, 0x65,
	0xab, 0x9c, 0x4a, 0x99, 0xde, 0x55, 0x0e, 0x89, 0xed, 0x4d, 0x52, 0x14, 0x45, 0xaf, 0x58, 0x6b,
	0x92, 0xda, 0x21, 0xbd, 0xc9, 0x6e, 0xa5, 0x4a, 0x05, 0x03, 0x23, 0x1a, 0x2b, 0x12, 0x80, 0x67,
	0x00, 0xdb, 0x4a, 0x1e, 0x20, 0x79, 0x80, 0x54, 0xe5, 0x01, 0x72, 0xca, 0x2d, 0x87, 0x3c, 0x42,
	0x2a, 0xc7, 0xbc, 0x40, 0x9e, 0x20, 0x87, 0x54, 0x72, 0xc8, 0x21, 0xc7, 0xd4, 0x0c, 0x30, 0xf8,
	0x1d, 0x4a, 0xf2, 0xee, 0xe6, 0x86, 0xe9, 0xf9, 0xba, 0xa7, 0xd1, 0xdd, 0xe8, 0xee, 0x69, 0xc0,
	0xfd, 0x8b, 0xc0, 0xb1, 0xcf, 0x5d, 0xea, 0x3c, 0x64, 0xe6, 0x2b, 0x62, 0x05, 0x33, 0x42, 0x1f,
	0xda, 0x8e, 0x4f, 0xe8, 0x99, 0x61, 0x92, 0x47, 0xcc, 0x6e, 0x7b, 0xd4, 0xf5, 0x5d, 0xb4, 0xcc,
	0xec, 0xf6, 0x9b, 0x8f, 0x77, 0xf6, 0xa6, 0xae, 0x3b, 0x9d, 0x91, 0x47, 0x82, 0xf8, 0x32, 0x38,
	0x7b, 0x64, 0x11, 0x66, 0x52, 0xdb, 0xf3, 0x5d, 0x1a, 0x02, 0x75, 0x0f, 0x76, 0x31, 0x99, 0xda,
	0xcc, 0x27, 0x14, 0x13, 0xe6, 0x06, 0xd4, 0x24, 0x03, 0xc3, 0x31, 0xa6, 0x7c, 0xf9, 0x3a, 0x20,
	0xcc, 0x47, 0x08, 0x2a, 0x74, 0xde, 0xb7, 0x5a, 0xda, 0x9e, 0xf6, 0xa0, 0x86, 0xc5, 0x33, 0x6a,
	0xc1, 0xea, 0x1b, 0x42, 0x99, 0xed, 0x3a, 0xad, 0x92, 0x20, 0xcb, 0x25, 0xda, 0x83, 0x35, 0xcf,
	0x9d, 0xd9, 0xe6, 0xc5, 0xa7, 0xd4, 0x0d, 0xbc, 0x56, 0x59, 0xec, 0xa6, 0x49, 0xfa, 0xf7, 0xe0,
	0xee, 0xc2, 0x13, 0x99, 0xe7, 0x3a, 0x8c, 0xe8, 0xff, 0x2a, 0xc3, 0xc6, 0x0b, 0xcf, 0x32, 0x7c,
	0x22, 0x95, 0x78, 0x00, 0x15, 0x83, 0x9d, 0xb3, 0x96, 0xb6, 0x57, 0x7e, 0xb0, 0x76, 0xb0, 0xdd,
	0x16, 0xaf, 0xd7, 0xee, 0xcc, 0x66, 0xae, 0x69, 0xf8, 0xb6, 0xeb, 0x74, 0xd8, 0x39, 0x16, 0x08,
	0xf4, 0x09, 0x54, 0x29, 0x99, 0x11, 0x83, 0x11, 0x26, 0x74, 0x5b, 0x3b, 0xd8, 0x2b, 0xa0, 0x71,
	0x04, 0x88, 0xa4, 0xe3, 0x98, 0x03, 0x1d, 0x41, 0xd3, 0x21, 0x6f, 0xc7, 0xa1, 0x69, 0x8d, 0x97,
	0x33, 0x32, 0x74, 0x2d, 0xc2, 0x5a, 0x65, 0x71, 0x2c, 0x8a, 0x04, 0x0d, 0xc9, 0x5b, 0x4e, 0xee,
	0x3b, 0x67, 0x2e, 0x56, 0xc1, 0xd1, 0x63, 0x58, 0x0f, 0x84, 0xfa, 0x56, 0xc8, 0x5e, 0x11, 0xec,
	0x37, 0x22, 0xf6, 0xf0, 0xcd, 0x62, 0x09, 0x19, 0x28, 0x3a, 0x06, 0x14, 0xf8, 0xf6, 0xcc, 0xfe,
	0x55, 0xa4, 0xa8, 0xe7, 0x52, 0x9f, 0xb5, 0x96, 0x85, 0x80, 0x96, 0x14, 0x90, 0x07, 0x60, 0x05,
	0x4f, 0xec, 0xb7, 0x95, 0x94, 0xdf, 0x9e, 0xc1, 0xa6, 0x43, 0xde, 0x76, 0x3c, 0x6f, 0x66, 0x87,
	0x96, 0x60, 0xad, 0xaa, 0x10, 0x7d, 0x47, 0xda, 0xc8, 0xb2, 0x52, 0xbb, 0xd2, 0x3e, 0x79, 0x26,
	0x34, 0x02, 0x44, 0xc9, 0xdc, 0x7d, 0x43, 0x32, 0xa2, 0x6a, 0x42, 0xd4, 0xdd, 0x48, 0x14, 0xce,
	0x03, 0xa4, 0x34, 0x05, 0xab, 0xfe, 0xd7, 0x65, 0xa8, 0x4b, 0x8f, 0x87, 0x41, 0x80, 0x3a, 0xb0,
	0x62, 0x98, 0x7c, 0x57, 0x44, 0x5e, 0xfd, 0xe0, 0xfb, 0x19, 0xf3, 0x49, 0x58, 0xbb, 0x23, 0x30,
	0xcf, 0xa8, 0x3b, 0x1f, 0xcb, 0x0f, 0x02, 0x47, 0x8c, 0xe8, 0x31, 0xd4, 0xb9, 0xe6, 0xb1, 0xdf,
	0x79, 0x44, 0x70, 0x15, 0xb7, 0x8a, 0x11, 0x91, 0x03, 0x22, 0x0c, 0xcd, 0x28, 0x28, 0xac, 0x34,
	0x7f, 0x18, 0x08, 0x0b, 0x23, 0x4a, 0x6a, 0x85, 0x55, 0xcc, 0x68, 0xc8, 0x65, 0x7e, 0x4d, 0x4c,
	0x3f, 0x2b, 0xb3, 0x92, 0xf1, 0x00, 0x2e, 0x20, 0x78, 0x6c, 0xab, 0x18, 0xd1, 0x67, 0xd0, 0x74,
	0x5c, 0x8b, 0x60, 0x62, 0xba, 0xf3, 0x39, 0x71, 0xac, 0x48, 0x5e, 0x18, 0x2c, 0xb7, 0x64, 0xb0,
	0x16, 0x10, 0x58, 0xc5, 0x85, 0x86, 0xb0, 0x1d, 0x9f, 0x91, 0x76, 0xea, 0x8a, 0x90, 0xb6, 0x93,
	0xd7, 0x2e, 0xe5, 0x56, 0x25, 0x1f, 0x97, 0x67, 0x98, 0x26, 0xf1, 0xf2, 0xf2, 0x56, 0x33, 0xf2,
	0x3a, 0x45, 0x08, 0x56, 0xf2, 0xa1, 0xc7, 0xb0, 0x21, 0xcf, 0x09, 0x3f, 0xaa, 0x30, 0x70, 0x9b,
	0x39, 0xc5, 0xc4, 0xeb, 0x66, 0x91, 0x9c, 0x55, 0x8a, 0x0c, 0x59, 0x6b, 0x19, 0xd6, 0x4e, 0x6a,
	0x0f, 0x67, 0x91, 0xfa, 0x23, 0x68, 0x2a, 0x02, 0x0c, 0xad, 0x43, 0x75, 0x38, 0xea, 0x74, 0x27,
	0xfd, 0xd1, 0xb0, 0xb1, 0x84, 0x00, 0x56, 0x70, 0x6f, 0xfc, 0xe5, 0xb0, 0xdb, 0xd0, 0xf4, 0x31,
	0x34, 0x15, 0x36, 0x42, 0xf7, 0x60, 0xc3, 0x48, 0x96, 0x71, 0x36, 0xcd, 0x12, 0xd1, 0x4d, 0x58,
	0xa1, 0xc4, 0x60, 0x71, 0x56, 0x8d, 0x56, 0xfa, 0x53, 0xae, 0x45, 0xc1, 0x26, 0xd7, 0x13, 0xaa,
	0xff, 0x14, 0xd6, 0xd3, 0xc6, 0xe1, 0x87, 0x70, 0xff, 0xc7, 0xf0, 0x68, 0xb5, 0xf0, 0xf0, 0x7d,
	0x58, 0x4f, 0x5b, 0x68, 0x11, 0xbf, 0xee, 0x40, 0xf5, 0x84, 0xda, 0x2e, 0xb5, 0xfd, 0x0b, 0xb4,
	0x0f, 0x1b, 0x5e, 0xf4, 0xfc, 0x85, 0x31, 0x0b, 0x88, 0x80, 0x2e, 0x1f, 0x2f, 0xe1, 0x2c, 0x19,
	0xb5, 0x61, 0x4b, 0x12, 0xba, 0x33, 0x83, 0xb1, 0xa1, 0x31, 0x27, 0xe1, 0xf1, 0xc7, 0x4b, 0xb8,
	0xb8, 0x75, 0x08, 0x50, 0x95, 0x44, 0xfd, 0xf7, 0x1a, 0x54, 0x65, 0x01, 0x41, 0x9f, 0x40, 0x8d,
	0x46, 0xcf, 0xb2, 0x48, 0xec, 0xc6, 0x91, 0x11, 0xd2, 0xe3, 0x07, 0xd6, 0x73, 0x7c, 0x7a, 0x81,
	0x13, 0x86, 0x9d, 0x01, 0xd4, 0xb3, 0x9b, 0xa8, 0x01, 0xe5, 0x73, 0x72, 0x11, 0xbd, 0x21, 0x7f,
	0x44, 0xf7, 0x61, 0xf9, 0x8d, 0x78, 0x95, 0xb0, 0xa8, 0x6c, 0x46, 0xd2, 0x3f, 0x0f, 0x0c, 0xc7,
	0xb7, 0xfd, 0x0b, 0x1c, 0xee, 0x3e, 0x29, 0xfd, 0x58, 0xd3, 0xf7, 0xa0, 0x2a, 0xc9, 0x68, 0x5b,
	0xb2, 0x71, 0x51, 0xe5, 0x08, 0xa5, 0xff, 0xb6, 0x02, 0x1b, 0x99, 0x0f, 0x5c, 0xf8, 0x32, 0x26,
	0x7c, 0x16, 0x1f, 0x9d, 0x25, 0x16, 0x3d, 0x5e, 0x52, 0x85, 0xd1, 0x3d, 0xd8, 0xf0, 0x0c, 0xea,
	0xdb, 0x7c, 0x29, 0x2c, 0x1a, 0x56, 0xe1, 0x2c, 0x11, 0x7d, 0x0c, 0x6b, 0xd2, 0x02, 0x1d, 0x76,
	0xde, 0xaa, 0x64, 0x5e, 0x4b, 0x9a, 0x03, 0xa7, 0x31, 0x68, 0x1f, 0xea, 0x73, 0xe3, 0x5d, 0x3a,
	0x77, 0x2d, 0x73, 0xbf, 0xe2, 0x1c, 0x15, 0xfd, 0x20, 0x71, 0x93, 0x28, 0x3f, 0x89, 0x5c, 0x19,
	0x21, 0x38, 0x06, 0xa0, 0x43, 0xb8, 0x43, 0xde, 0x11, 0x33, 0xe0, 0xac, 0x13, 0x7b, 0x4e, 0xdc,
	0xc0, 0x1f, 0xd8, 0xb3, 0x99, 0x3d, 0x26, 0xa6, 0xeb, 0x58, 0x3c, 0x61, 0x70, 0xc3, 0x5d, 0x8a,
	0x41, 0x07, 0x50, 0xf1, 0x8d, 0xa9, 0xcc, 0x09, 0xbb, 0xaa, 0xf6, 0xa0, 0x3d, 0x31, 0xa6, 0x91,
	0xe7, 0x05, 0x16, 0x3d, 0x87, 0xa6, 0x37, 0x33, 0x4c, 0x32, 0x27, 0x8e, 0xdf, 0x75, 0x1d, 0xe6,
	0x53, 0xc3, 0x76, 0xfc, 0x56, 0x4d, 0xe8, 0x2b, 0xf3, 0xd3, 0x49, 0x11, 0x81, 0x55, 0x6c, 0x3b,
	0x3f, 0x82, 0x5a, 0x7c, 0x80, 0x22, 0x7a, 0xb6, 0xd3, 0xd1, 0x53, 0x4b, 0x07, 0xcb, 0x3f, 0x4a,
	0x70, 0x43, 0x59, 0x75, 0xaf, 0x99, 0x33, 0xee, 0x40, 0xed, 0x75, 0x40, 0x02, 0x92, 0x7c, 0x3a,
	0x38, 0x21, 0x5c, 0x33, 0x14, 0x1e, 0x42, 0x39, 0x98, 0xda, 0x51, 0x08, 0xdc, 0x96, 0x75, 0x96,
	0x11, 0x2a, 0x3a, 0x36, 0xde, 0xa5, 0xd0, 0x79, 0xa8, 0x1a, 0xc7, 0xa1, 0x27, 0x91, 0xb5, 0xc3,
	0x42, 0xb3, 0x7f, 0x59, 0xeb, 0x50, 0xb0, 0xfa, 0x55, 0xde, 0x5e, 0xb9, 0xda, 0xdb, 0xdf, 0xdc,
	0xd6, 0x67, 0xd0, 0x5a, 0xd4, 0x95, 0x5c, 0xd3, 0xda, 0x05, 0x7b, 0x96, 0x14, 0xf6, 0xd4, 0x0f,
	0x61, 0x5b, 0x65, 0x3d, 0xde, 0x92, 0x05, 0x8c, 0x50, 0xd9, 0x4a, 0xf3, 0x67, 0x9e, 0x4e, 0xa7,
	0x1c, 0x17, 0xf6, 0x26, 0x35, 0x1c, 0xad, 0x74, 0x06, 0x4d, 0x45, 0xf0, 0xa1, 0x21, 0x34, 0x98,
	0x3d, 0xf7, 0x66, 0x24, 0x15, 0xb2, 0x5a, 0xa6, 0xcd, 0x1d, 0x8b, 0x6d, 0x05, 0xef, 0xf1, 0x12,
	0x2e, 0xf0, 0x1e, 0xae, 0x03, 0x98, 0xf1, 0x4a, 0xff, 0xbb, 0x06, 0xb7, 0x16, 0xf2, 0xa3, 0x2f,
	0xe0, 0x26, 0xcf, 0xf5, 0x9d, 0xb3, 0x33, 0xdb, 0xe1, 0x69, 0x39, 0xaf, 0xc1, 0x6e, 0xaa, 0xe5,
	0x28, 0x82, 0x18, 0x5e, 0xc0, 0x8d, 0xce, 0xe0, 0x76, 0x92, 0xe6, 0xe4, 0x7e, 0xc7, 0xf7, 0xa9,
	0xfd, 0x32, 0xf0, 0x65, 0xc2, 0xbd, 0x57, 0xfc, 0xa8, 0x15, 0x47, 0x5c, 0x26, 0x48, 0x7f, 0x05,
	0x1f, 0x2c, 0x50, 0x0d, 0x0d, 0x60, 0xcb, 0x37, 0xe8, 0x94, 0xf8, 0xbd, 0x77, 0x1e, 0x25, 0x8c,
	0xa5, 0x9a, 0x45, 0xd9, 0xcf, 0x4a, 0xb6, 0x49, 0x0e, 0x87, 0x8b, 0x9c, 0xfa, 0xbf, 0x35, 0xf8,
	0xf0, 0x52, 0x45, 0x79, 0x90, 0x32, 0xd3, 0xf5, 0x48, 0x14, 0x0b, 0xe1, 0x42, 0xa8, 0x41, 0x8d,
	0x6f, 0xaa, 0x46, 0x9e, 0x53, 0xe4, 0x6b, 0xdb, 0xe9, 0x1a, 0xd4, 0xb2, 0x1d, 0x63, 0xc6, 0xb3,
	0x71, 0x39, 0xca, 0xd7, 0x19, 0x6a, 0x94, 0xd7, 0xd3, 0xb8, 0x4a, 0x9c, 0xd7, 0xd3, 0xb8, 0x1d,
	0x7e, 0xb7, 0x7a, 0x1d, 0xd8, 0x94, 0x58, 0x22, 0xf3, 0x57, 0x71, 0xbc, 0xd6, 0xff, 0xa9, 0x41,
	0x6b, 0x91, 0x6e, 0xe8, 0x53, 0xa8, 0x87, 0x46, 0x1a, 0x79, 0x84, 0x1a, 0xbe, 0x4b, 0xa3, 0x88,
	0xb9, 0xf2, 0xa5, 0x72, 0x6c, 0x3c, 0xdb, 0x85, 0x14, 0x5e, 0x22, 0xa3, 0x6c, 0x17, 0x13, 0x90,
	0x0e, 0xeb, 0xe1, 0x42, 0x74, 0x17, 0x61, 0xb7, 0x5e, 0xc3, 0x19, 0x9a, 0xfe, 0x0c, 0x6e, 0x66,
	0x4f, 0x8b, 0x65, 0xaf, 0x40, 0xa9, 0x1f, 0xb5, 0x73, 0xc3, 0xd1, 0xe4, 0xb4, 0x3f, 0x6c, 0x68,
	0xa8, 0x06, 0xcb, 0xbd, 0x5f, 0xf4, 0xc7, 0x93, 0x46, 0x09, 0x6d, 0x40, 0x8d, 0x93, 0xc3, 0x65,
	0x59, 0xff, 0x9b, 0x06, 0xb7, 0x16, 0xde, 0x28, 0xd1, 0x18, 0xb6, 0x93, 0x48, 0x64, 0x13, 0x37,
	0xda, 0x8f, 0x5a, 0x93, 0xbb, 0x8b, 0xef, 0x0f, 0xe1, 0x15, 0x49, 0xc9, 0x8c, 0x7e, 0x09, 0x1f,
	0x18, 0xe9, 0x92, 0x96, 0x92, 0x1b, 0xc6, 0x88, 0xae, 0xbc, 0x17, 0x67, 0x45, 0x2f, 0x12, 0xa1,
	0xff, 0x8e, 0x3b, 0x70, 0x81, 0x42, 0xc5, 0xbc, 0xa7, 0xa9, 0xea, 0xc8, 0xf5, 0xda, 0x13, 0x9e,
	0x05, 0x03, 0xdb, 0x8a, 0x4a, 0x91, 0x78, 0x46, 0x2d, 0x58, 0x9d, 0x13, 0xc6, 0x8c, 0x29, 0x11,
	0xa1, 0x57, 0xc3, 0x72, 0xa9, 0xff, 0x51, 0x83, 0xdb, 0x97, 0xbc, 0xcf, 0x77, 0xaa, 0x59, 0xa6,
	0x09, 0xe3, 0x55, 0xa5, 0x9c, 0x6f, 0xc2, 0x78, 0x7d, 0x59, 0xac, 0xeb, 0x9f, 0x4a, 0xb0, 0x96,
	0x1a, 0x0e, 0x2c, 0x6c, 0xb5, 0x0f, 0x01, 0x0c, 0x99, 0x95, 0x58, 0xce, 0x77, 0x29, 0xfe, 0x76,
	0x9c, 0xba, 0xa2, 0x12, 0x9a, 0xe2, 0x42, 0x1d, 0x68, 0xb2, 0x64, 0xee, 0x20, 0xfb, 0x35, 0xa1,
	0xb1, 0xa2, 0x8d, 0x53, 0x61, 0x51, 0x17, 0x9a, 0xe4, 0x9d, 0xcd, 0x7c, 0xdb, 0x99, 0x16, 0xef,
	0xa3, 0x8a, 0x3b, 0xb2, 0x0a, 0xbd, 0xf3, 0x13, 0xd8, 0xcc, 0xa9, 0xf9, 0x5e, 0x25, 0xf9, 0xbf,
	0x25, 0x79, 0xf1, 0xbf, 0xd2, 0x6a, 0x3d, 0x85, 0xd5, 0xee, 0x2b, 0x67, 0x2a, 0xff, 0x6f, 0xc3,
	0x3d, 0x89, 0x47, 0x13, 0x15, 0x31, 0x9a, 0xd0, 0x17, 0x68, 0x11, 0xdf, 0x1c, 0xf1, 0x40, 0xce,
	0x24, 0xbe, 0xad, 0xbd, 0xfa, 0xfc, 0x36, 0x96, 0x88, 0x45, 0x75, 0x80, 0x23, 0xdc, 0xe9, 0x0f,
	0x4f, 0x87, 0xa3, 0xa3, 0x5e, 0x63, 0x09, 0x6d, 0xc2, 0xda, 0x51, 0xaf, 0x3b, 0x1a, 0xf4, 0xc7,
	0x63, 0x7e, 0x39, 0xd5, 0x50, 0x0b, 0xb6, 0x43, 0xc0, 0x64, 0x74, 0x3a, 0xee, 0x1e, 0xf7, 0x8e,
	0x5e, 0x3c, 0xef, 0x1c, 0x3e, 0xef, 0x35, 0x4a, 0xba, 0x05, 0x5b, 0x85, 0x49, 0x12, 0xaa, 0x43,
	0xc9, 0x96, 0x86, 0x2f, 0xd9, 0x16, 0xfa, 0x19, 0x20, 0xc3, 0xf4, 0x03, 0x63, 0xf6, 0x82, 0x11,
	0x2b, 0x36, 0x56, 0x49, 0x6d, 0x2c, 0x05, 0x54, 0xff, 0x4b, 0x19, 0x20, 0x89, 0x97, 0x6b, 0xde,
	0x73, 0x06, 0x50, 0x4f, 0x08, 0xbc, 0xd7, 0xcb, 0xb9, 0x3b, 0x11, 0x98, 0x7a, 0x4c, 0x5a, 0xcd,
	0x1c, 0xb3, 0x32, 0xe3, 0x3c, 0x85, 0x86, 0xbc, 0xda, 0x9c, 0x10, 0x2a, 0xa4, 0x88, 0x9a, 0xa6,
	0x78, 0xad, 0x02, 0xf0, 0xfd, 0x2e, 0x38, 0x99, 0x0e, 0x7d, 0x35, 0xdf, 0xa1, 0x27, 0xd1, 0x5e,
	0xcd, 0x44, 0x7b, 0x21, 0x63, 0xd5, 0xae, 0xd5, 0x8f, 0x82, 0x22, 0xfb, 0xed, 0x74, 0xa0, 0xa9,
	0x30, 0xd3, 0x7b, 0xc5, 0xdd, 0xaf, 0xe1, 0x86, 0x72, 0x32, 0xf5, 0x9d, 0x5e, 0x5c, 0x93, 0x11,
	0x44, 0x39, 0x33, 0x82, 0xf8, 0x8d, 0x06, 0xa8, 0x38, 0xc7, 0x42, 0x3f, 0x87, 0x5d, 0x2a, 0x29,
	0xc4, 0x1a, 0x2b, 0x3e, 0x6a, 0x4d, 0xed, 0xd0, 0x2b, 0xd8, 0xd2, 0x19, 0xbe, 0x94, 0xcd, 0xf0,
	0xff, 0x51, 0x55, 0xfd, 0x78, 0x64, 0x29, 0xe3, 0x4c, 0x4b, 0xc5, 0xd9, 0x57, 0xb0, 0xe9, 0x13,
	0x3a, 0xb7, 0x9d, 0xd0, 0xf8, 0x17, 0x5e, 0x28, 0xb3, 0x7e, 0xf0, 0xd1, 0x55, 0x43, 0xc4, 0xf6,
	0x24, 0xcb, 0x87, 0xf3, 0x82, 0xd2, 0x7a, 0x96, 0xb3, 0x7a, 0x0e, 0x60, 0x33, 0xc7, 0x8d, 0xb6,
	0x60, 0x63, 0x3c, 0x19, 0x9d, 0x9c, 0xf4, 0x8e, 0x4e, 0x0f, 0xbf, 0x3c, 0xc5, 0x83, 0xc6, 0x12,
	0x5a, 0x83, 0xd5, 0x49, 0x7f, 0xd0, 0x1b, 0xbd, 0x98, 0x34, 0x34, 0xb4, 0x03, 0x37, 0x4f, 0x70,
	0xaf, 0x37, 0x38, 0x99, 0x84, 0x88, 0x28, 0x59, 0xf4, 0x70, 0xa3, 0xa4, 0x0f, 0xa1, 0x7e, 0x42,
	0x89, 0xc5, 0x3d, 0x45, 0x58, 0x87, 0x4e, 0xd9, 0x35, 0xdd, 0x9e, 0x04, 0x77, 0x29, 0x33, 0x2b,
	0xb2, 0xf8, 0x45, 0x6c, 0x7c, 0xe1, 0x98, 0xf1, 0x48, 0xad, 0x6b, 0x98, 0xaf, 0x88, 0x90, 0x7c,
	0x0c, 0xc8, 0x60, 0x2c, 0x98, 0x67, 0x87, 0xa4, 0x5a, 0x66, 0x02, 0xde, 0xc9, 0x03, 0xb0, 0x82,
	0x47, 0xff, 0x1c, 0xb6, 0x0a, 0xc0, 0x6f, 0xa7, 0xf8, 0xc1, 0x9f, 0x35, 0xa8, 0x25, 0x63, 0xc0,
	0xaf, 0xe1, 0x83, 0x05, 0xbf, 0x32, 0xd0, 0xfd, 0x38, 0xe6, 0x2e, 0xfb, 0xb9, 0xb2, 0xb3, 0x7f,
	0x15, 0x2c, 0xfa, 0x23, 0xb2, 0x84, 0x9e, 0xc2, 0x4a, 0x58, 0x5e, 0xd0, 0x76, 0x6e, 0x10, 0x1e,
	0x4a, 0xba, 0xa1, 0x1c, 0x8f, 0xeb, 0x4b, 0x0f, 0xb4, 0x8f, 0xb4, 0x27, 0x4f, 0xa1, 0xc6, 0xec,
	0x53, 0x46, 0x4c, 0x4a, 0x7c, 0xf4, 0x61, 0x3b, 0xfc, 0x2b, 0xd4, 0x96, 0x7f, 0x85, 0xda, 0xcf,
	0x6c, 0x32, 0xb3, 0x46, 0x5e, 0x68, 0xe9, 0x3f, 0x54, 0xc3, 0xce, 0x9e, 0xf1, 0xfb, 0x36, 0x25,
	0xfe, 0x61, 0xe5, 0xab, 0x12, 0xb3, 0x5f, 0xae, 0x08, 0xf4, 0x0f, 0xff, 0x17, 0x00, 0x00, 0xff,
	0xff, 0x7d, 0xa2, 0xab, 0x49, 0x81, 0x1a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SchedulerClient is the client API for Scheduler service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SchedulerClient interface {
	// Register a RM, if it is a reconnect from previous RM the call will
	// trigger a cleanup of all in-memory data and resync with RM.
	RegisterResourceManager(ctx context.Context, in *RegisterResourceManagerRequest, opts ...grpc.CallOption) (*RegisterResourceManagerResponse, error)
	// Update Scheduler status (this includes node status update, allocation request
	// updates, etc. And receive updates from scheduler for allocation changes,
	// any required status changes, etc.
	Update(ctx context.Context, opts ...grpc.CallOption) (Scheduler_UpdateClient, error)
}

type schedulerClient struct {
	cc *grpc.ClientConn
}

func NewSchedulerClient(cc *grpc.ClientConn) SchedulerClient {
	return &schedulerClient{cc}
}

func (c *schedulerClient) RegisterResourceManager(ctx context.Context, in *RegisterResourceManagerRequest, opts ...grpc.CallOption) (*RegisterResourceManagerResponse, error) {
	out := new(RegisterResourceManagerResponse)
	err := c.cc.Invoke(ctx, "/si.v1.Scheduler/RegisterResourceManager", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schedulerClient) Update(ctx context.Context, opts ...grpc.CallOption) (Scheduler_UpdateClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Scheduler_serviceDesc.Streams[0], "/si.v1.Scheduler/Update", opts...)
	if err != nil {
		return nil, err
	}
	x := &schedulerUpdateClient{stream}
	return x, nil
}

type Scheduler_UpdateClient interface {
	Send(*UpdateRequest) error
	Recv() (*UpdateResponse, error)
	grpc.ClientStream
}

type schedulerUpdateClient struct {
	grpc.ClientStream
}

func (x *schedulerUpdateClient) Send(m *UpdateRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *schedulerUpdateClient) Recv() (*UpdateResponse, error) {
	m := new(UpdateResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SchedulerServer is the server API for Scheduler service.
type SchedulerServer interface {
	// Register a RM, if it is a reconnect from previous RM the call will
	// trigger a cleanup of all in-memory data and resync with RM.
	RegisterResourceManager(context.Context, *RegisterResourceManagerRequest) (*RegisterResourceManagerResponse, error)
	// Update Scheduler status (this includes node status update, allocation request
	// updates, etc. And receive updates from scheduler for allocation changes,
	// any required status changes, etc.
	Update(Scheduler_UpdateServer) error
}

func RegisterSchedulerServer(s *grpc.Server, srv SchedulerServer) {
	s.RegisterService(&_Scheduler_serviceDesc, srv)
}

func _Scheduler_RegisterResourceManager_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterResourceManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchedulerServer).RegisterResourceManager(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/si.v1.Scheduler/RegisterResourceManager",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchedulerServer).RegisterResourceManager(ctx, req.(*RegisterResourceManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Scheduler_Update_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SchedulerServer).Update(&schedulerUpdateServer{stream})
}

type Scheduler_UpdateServer interface {
	Send(*UpdateResponse) error
	Recv() (*UpdateRequest, error)
	grpc.ServerStream
}

type schedulerUpdateServer struct {
	grpc.ServerStream
}

func (x *schedulerUpdateServer) Send(m *UpdateResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *schedulerUpdateServer) Recv() (*UpdateRequest, error) {
	m := new(UpdateRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Scheduler_serviceDesc = grpc.ServiceDesc{
	ServiceName: "si.v1.Scheduler",
	HandlerType: (*SchedulerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterResourceManager",
			Handler:    _Scheduler_RegisterResourceManager_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Update",
			Handler:       _Scheduler_Update_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "yunikorn-scheduler-interface/si.proto",
}
